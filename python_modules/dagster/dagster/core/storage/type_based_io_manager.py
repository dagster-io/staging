from collections import Counter
from typing import Any, Dict, List, Optional, Tuple

from dagster import check
from dagster.core.definitions.definition_config_schema import ConfiguredDefinitionConfigSchema
from dagster.core.definitions.resource import ResourceDefinition, ScopedResourcesBuilder
from dagster.core.errors import DagsterInvariantViolationError
from dagster.core.execution.context.init import InitResourceContext
from dagster.core.execution.context.system import InputContext, OutputContext
from dagster.core.types.dagster_type import resolve_dagster_type
from dagster.utils.merger import merge_dicts

from .io_manager import IOManager, IOManagerDefinition, io_manager

DEFAULT_MANAGER_CONFIG_KEY = "default"


class TypeBasedIOManager(IOManager):
    def __init__(self, type_managers: Dict[str, IOManager], default: IOManager):
        self.type_managers = type_managers
        self.default = default

    def handle_output(self, context, obj):
        type_key = context.dagster_type.key
        chosen_io_manager = self.type_managers.get(type_key, self.default)
        if chosen_io_manager is None:
            raise DagsterInvariantViolationError(
                f'Type-based IO manager does not have a manager for type with key "{type_key}"'
                f"Registered types keys: {list(self.type_managers.keys())}"
            )

        context_with_sub_config = _copy_namedtuple_with_overrides(
            context, OutputContext, resource_config=context.resource_config.get(type_key)
        )
        return chosen_io_manager.handle_output(context_with_sub_config, obj)

    def load_input(self, context):
        type_key = context.dagster_type.key
        chosen_io_manager = self.type_managers.get(type_key, self.default)
        output_context_with_sub_config = _copy_namedtuple_with_overrides(
            context.upstream_output,
            OutputContext,
            resource_config=context.resource_config.get(type_key),
        )
        input_context_with_sub_config = _copy_namedtuple_with_overrides(
            context,
            InputContext,
            upstream_output=output_context_with_sub_config,
            resource_config=context.resource_config.get(type_key),
        )
        return chosen_io_manager.load_input(input_context_with_sub_config)


def type_based_io_manager(
    type_manager_defs: List[Tuple[Any, IOManagerDefinition]],
    default_manager_def: Optional[IOManagerDefinition] = None,
) -> IOManagerDefinition:
    """
    Returns an IOManagerDefinition that wraps a set of IOManagerDefinitions and selects which to
    use based on the dagster type of the output that it's storing or input that it's loading.

    Args:
        type_manager_defs: Each element in the list is an object that can be resolved to a
            :py:class:`DagsterType`, along with an IOManagerDefinition to use when storing
            or loading outputs of that type. It must contain no duplicate types, and
            IOManagerDefinitions that are generated by invoking :py:func:`configured` are not
            currently supported.
        default_manager_def: The IOManagerDefinition to use for inputs and outputs that don't match
            any of the provided types.  If None, then the IOManager will error at runtime if an
            unsupported type is provided.
    """
    # resolve to dagster types
    dagster_type_io_manager_defs = [
        (resolve_dagster_type(dagster_type), io_manager_def)
        for dagster_type, io_manager_def in type_manager_defs
    ]

    check.opt_inst_param(default_manager_def, "default_manager_def", IOManagerDefinition)
    for dagster_type, io_manager_def in dagster_type_io_manager_defs:
        check.invariant(
            isinstance(io_manager_def, IOManagerDefinition),
            f"Supplied IO manager definition for type {dagster_type} is not an IOManagerDefinition",
        )

    # make sure no duplicate types
    type_key_counts = Counter(dagster_type.key for dagster_type, _ in dagster_type_io_manager_defs)
    for type_key, count in type_key_counts.items():
        check.invariant(
            count == 1,
            f'Dagster type with key "{type_key}" occurs {count} times in type_manager_defs '
            f"but must only occur once.",
        )

    check.invariant(
        all(
            dagster_type.key != DEFAULT_MANAGER_CONFIG_KEY
            for dagster_type, _ in dagster_type_io_manager_defs
        ),
        f"type_based_io_manager does not support dagster types with key"
        f'"{DEFAULT_MANAGER_CONFIG_KEY}", because it is reserved for the default.',
    )

    # we don't yet support configured
    for dagster_type, io_manager_def in type_manager_defs:
        check.invariant(
            not isinstance(io_manager_def.config_schema, ConfiguredDefinitionConfigSchema),
            f"IOManagerDefinition provided for type {dagster_type} was configured, but "
            "type_based_io_manager does not support configured IOManagerDefinitions.",
        )

    check.invariant(
        not default_manager_def
        or not isinstance(default_manager_def.config_schema, ConfiguredDefinitionConfigSchema),
        "default_manager_def was configured, but type_based_io_manager does not support "
        "configured IOManagerDefinitions.",
    )

    config_schema = {
        dagster_type.key: io_manager_def.config_schema.as_field()
        for dagster_type, io_manager_def in dagster_type_io_manager_defs
        if io_manager_def.config_schema
    }

    if default_manager_def and default_manager_def.config_schema:
        config_schema[DEFAULT_MANAGER_CONFIG_KEY] = default_manager_def.config_schema.as_field()

    @io_manager(config_schema=config_schema)
    def _io_manager(context):
        type_managers = {
            dagster_type.key: _init_sub_resource(context, dagster_type.key, io_manager_def)
            for dagster_type, io_manager_def in dagster_type_io_manager_defs
        }
        default_manager = (
            _init_sub_resource(context, DEFAULT_MANAGER_CONFIG_KEY, default_manager_def)
            if default_manager_def
            else None
        )

        return TypeBasedIOManager(type_managers=type_managers, default=default_manager)

    return _io_manager


def _copy_namedtuple_with_overrides(named_tuple, klass, **overrides):
    """Returns a copy of the given named tuple, with the fields in overrides overridden."""
    kwargs = merge_dicts(named_tuple._asdict(), overrides)
    return klass(**kwargs)


def _init_sub_resource(
    context: InitResourceContext, config_key: str, sub_resource_def: ResourceDefinition
):
    resources = ScopedResourcesBuilder(context.resources._asdict()).build(
        sub_resource_def.required_resource_keys
    )
    return sub_resource_def.resource_fn(
        _copy_namedtuple_with_overrides(
            context,
            InitResourceContext,
            resource_config=context.resource_config.get(config_key),
            resources=resources,
        )
    )
