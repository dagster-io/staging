---
title: Versioning and Memoization | Dagster
---

# Versioning and Memoization <Experimental />

<CodeReferenceLink filePath="examples/memoized_development" />

This guide describes how to use Dagster's memoization and versioning features.

When memoization is enabled, Dagster will retrieve outputs from storage if they already have been computed, instead of recomputing them. Versions allow users to express to Dagster whether outputs have changed and thus require re-computation.

## Computing Versions

A <PyObject object="VersionStrategy"/> can be implemented to compute versions from solids and resources. The <PyObject object="VersioningStrategy" method="get_op_version"/> method ingests a solid definition, and returns a string representing the version of that solid. Dagster expects `get_op_version` to produce a valid alphanumeric string for every `op` in a job - otherwise an error will be thrown.

```python file=/guides/dagster/memoization/memoization.py startafter=start_op_strategy endbefore=end_op_strategy
from dagster import VersionStrategy
import inspect
import hashlib


class OpSourceHashStrategy(VersionStrategy):
    def get_op_version(self, op_def):
        # Track changes in the op's source code
        code_as_str = inspect.getsource(op_def.compute_fn.decorated_fn)

        return hashlib.sha1(code_as_str.encode("utf-8")).hexdigest()
```

In the above example, we ingest an op, retrieve the source code as a string from the decorated function, and then return a string-based hash of that source code. Note that `OpSourceHashStrategy` only takes into account the source code of the decorated function, and changes to functions called by the op will not be tracked. This approach can be extended freely to track additional information that might be pertinent to the computation changing.

Providing a <PyObject object="VersionStrategy"/> to a job enables memoization on that job. Consider the following graph:

```python file=/guides/dagster/memoization/memoization.py startafter=start_memoized_graph endbefore=end_memoized_graph
from dagster import graph, op


@op
def emit_five():
    return 5


@op
def add_number(x):
    return x + 1


@graph
def emit_number():
    add_number(emit_five())
```

When constructing a job out of this graph, populate the `version_strategy` parameter.

```python file=/guides/dagster/memoization/memoization.py startafter=start_memoized_job endbefore=end_memoized_job
emit_number_job = emit_number.to_job(version_strategy=OpSourceHashStrategy())
```

## Changes that memoization tracks

Dagster's memoization functionality automatically tracks changes to op config, resource config, input values, and changes in the output of `get_op_version` for a given op. That is, if any of these values change from one pipeline run to the next, the outputs affected by these changes will be recomputed.

### Tracking changes to resources

While it isn't required to use memoization, resources can optionally be tagged with a version. To opt-in to this behavior, implement the <PyObject object="VersioningStrategy" method="get_resource_version"/> method.

When an op requires a resource, and that resource has a version, then the outputs of that op will be re-computed when the resource version changes. Consider the following graph:

```python file=/guides/dagster/memoization/memoization.py startafter=start_graph_reqs_resources endbefore=end_graph_reqs_resources
from dagster import graph, op


@op(required_resource_keys={"foo", "bar"})
def foobar_op():
    pass


@graph
def foobar_graph():
    foobar_op()
```

Let's say we want to tag a version to the resource `foo`, but not `bar`. We can implement a version strategy like so:

```python file=/guides/dagster/memoization/memoization.py startafter=start_version_strategy_resources endbefore=end_version_strategy_resources
from dagster import VersionStrategy


class OpAndResourcesSourceHashStrategy(VersionStrategy):
    def _get_source_hash(self, fn):
        code_as_str = inspect.getsource(fn)
        return hashlib.sha1(code_as_str.encode("utf-8")).hexdigest()

    def get_op_version(self, op_def):
        # Track changes in the op's source code
        return self._get_source_hash(op_def.compute_fn.decorated_fn)

    def get_resource_version(self, resource_key, resource_def):
        if resource_key == "foo":
            return self._get_source_hash(resource_def.resource_fn)
        else:
            return None
```

Notice here how we only provide a version if the resource key `foo` is passed in. Then, Dagster take into account changes to `foo` when deciding whether to recompute the outputs of `foobar_op`, but not `bar`.

## Using Root Input Managers with Memoization

Root input managers are compatible with memoization functionality, but by default, the system does not track code their code changes. Users can opt in to to tracking changes from the `get_resource_version` function (since root input managers are resources).

## Using Custom IO Managers with Memoization

When using memoization, all IO managers used in the job must subclass

<PyObject object="MemoizableIOManager" />. In addition to `handle_output` and
`load_input`, Memoizable IO Managers implement `has_output`, which returns
`True` or `False` based upon the existence of the output specified by the
context. For an example implementation of a MemoizableIOManager , see the
fs_io_manager.

## Disabling Memoization

Memoization can be toggled off using the tag <PyObject object="MEMOIZED_RUN_TAG" />, which can be provided to a run.

```python file=/guides/dagster/memoization/memoization.py startafter=start_disable_memoization endbefore=end_disable_memoization
from dagster import MEMOIZED_RUN_TAG

disabled_result = emit_number_job.execute_in_process(tags={MEMOIZED_RUN_TAG: "false"})
```

## Backcompat with Pipeline/Solid APIs

If using the `@pipeline` or `@solid` APIs, a version strategy can instead be provided to the pipeline decorator.
