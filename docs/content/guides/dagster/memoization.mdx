---
title: Versioning and Memoization | Dagster
---

# Versioning and Memoization <Experimental />

<CodeReferenceLink filePath="examples/memoized_development" />

This example describes how to use Dagster's memoization and versioning features.

When memoization is enabled, Dagster will retrieve outputs from storage if they already have been computed, instead of recomputing them. Coupled with this is the ability to tag user code with a version, which is a string meant to track meaningful changes to the code and config that construct the output. By default, the system will use versions to track changes to outputs, and determine if they need to be recomputed.

## Computing Versions

A <PyObject object="VersionStrategy"/> can be implemented to compute versions from solids and resources. The <PyObject object="VersioningStrategy" method="get_op_version"/> method ingests a solid definition, and returns a string representing the version of that solid.

```python file=/guides/dagster/memoization/memoization.py startafter=start_op_strategy endbefore=end_op_strategy
from dagster import VersionStrategy
import inspect
import hashlib


class TrackOpChangesStrategy(VersionStrategy):
    def get_op_version(self, op_def):
        # Track changes in the op's source code
        code_as_str = inspect.getsource(op_def.compute_fn.decorated_fn)

        return hashlib.sha1(code_as_str.encode("utf-8")).hexdigest()
```

Providing a <PyObject object="VersionStrategy"/> to a job enables memoization on that job. Consider the following graph:

```python file=/guides/dagster/memoization/memoization.py startafter=start_memoized_graph endbefore=end_memoized_graph
from dagster import graph, op


@op
def emit_five():
    return 5


@op
def add_number(x):
    return x + 1


@graph
def emit_number():
    add_number(emit_five())
```

When constructing a job out of this graph, populate the `version_strategy` parameter.

```python file=/guides/dagster/memoization/memoization.py startafter=start_memoized_job endbefore=end_memoized_job
emit_number_job = emit_number.to_job(version_strategy=TrackOpChangesStrategy())
```

## Changes that memoization tracks

Dagster's memoization functionality automatically tracks changes to op config, resource config, input values, and changes in the output of `get_op_version` for a given op. That is, if any of these values change from one pipeline run to the next, the outputs affected by these changes will be recomputed.

### Tracking changes to resources

Optionally, changes to resources can also be tracked. To opt-in to this behavior, implement the <PyObject object="VersioningStrategy" method="get_op_version"/> method.

```python file=/guides/dagster/memoization/memoization.py startafter=start_version_strategy_resources endbefore=end_version_strategy_resources
No match for startAfter value "start_version_strategy_resources"
```

Changes to resources will only affect the memoization status of outputs from ops that use the resource.

## Using Root Input Managers with Memoization

Root input managers are compatible with memoization functionality, but by default, the system does not track code their code changes. Users can opt in to to tracking changes from the `get_resource_version` function (since root input managers are resources).

## Using Custom IO Managers with Memoization

When using memoization, all IO managers used in the job must subclass

<PyObject object="MemoizableIOManager" />. In addition to `handle_output` and
`load_input`, Memoizable IO Managers implement `has_output`, which returns
`True` or `False` based upon the existence of the output specified by the
context. For an example implementation of a MemoizableIOManager , see the
fs_io_manager.

## Disabling Memoization

Memoization can be toggled off using the tag <PyObject object="MEMOIZED_RUN_TAG" />, which can be provided to a run.

## Backcompat with Pipeline/Solid APIs

If using the `@pipeline` or `@solid` APIs, a version strategy can instead be provided to the pipeline decorator.
