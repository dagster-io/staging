{"parents": [{"link": "../../../../../", "title": "Module code"}], "title": "dagster.core.storage.runs.base", "body": "<h1>Source code for dagster.core.storage.runs.base</h1><div class=\"highlight\"><pre>\n<span></span><span class=\"kn\">from</span> <span class=\"nn\">abc</span> <span class=\"kn\">import</span> <span class=\"n\">ABCMeta</span><span class=\"p\">,</span> <span class=\"n\">abstractmethod</span>\n\n<span class=\"kn\">import</span> <span class=\"nn\">six</span>\n\n\n<div class=\"viewcode-block\" id=\"RunStorage\"><a class=\"viewcode-back\" href=\"../../../../../../sections/api/apidocs/internals/#dagster.core.storage.runs.RunStorage\">[docs]</a><span class=\"k\">class</span> <span class=\"nc\">RunStorage</span><span class=\"p\">(</span><span class=\"n\">six</span><span class=\"o\">.</span><span class=\"n\">with_metaclass</span><span class=\"p\">(</span><span class=\"n\">ABCMeta</span><span class=\"p\">)):</span>\n    <span class=\"sd\">&quot;&quot;&quot;Abstract base class for storing pipeline run history.</span>\n\n<span class=\"sd\">    Note that run storages using SQL databases as backing stores should implement</span>\n<span class=\"sd\">    :py:class:`~dagster.core.storage.runs.SqlRunStorage`.</span>\n\n<span class=\"sd\">    Users should not directly instantiate concrete subclasses of this class; they are instantiated</span>\n<span class=\"sd\">    by internal machinery when ``dagit`` and ``dagster-graphql`` load, based on the values in the</span>\n<span class=\"sd\">    ``dagster.yaml`` file in ``$DAGSTER_HOME``. Configuration of concrete subclasses of this class</span>\n<span class=\"sd\">    should be done by setting values in that file.</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n\n    <span class=\"nd\">@abstractmethod</span>\n    <span class=\"k\">def</span> <span class=\"nf\">add_run</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">pipeline_run</span><span class=\"p\">):</span>\n        <span class=\"sd\">&quot;&quot;&quot;Add a run to storage.</span>\n\n<span class=\"sd\">        If a run already exists with the same ID, raise DagsterRunAlreadyExists</span>\n<span class=\"sd\">        If the run&#39;s snapshot ID does not exist raise DagsterSnapshotDoesNotExist</span>\n\n<span class=\"sd\">        Args:</span>\n<span class=\"sd\">            pipeline_run (PipelineRun): The run to add.</span>\n<span class=\"sd\">        &quot;&quot;&quot;</span>\n\n    <span class=\"nd\">@abstractmethod</span>\n    <span class=\"k\">def</span> <span class=\"nf\">handle_run_event</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">run_id</span><span class=\"p\">,</span> <span class=\"n\">event</span><span class=\"p\">):</span>\n        <span class=\"sd\">&quot;&quot;&quot;Update run storage in accordance to a pipeline run related DagsterEvent</span>\n\n<span class=\"sd\">        Args:</span>\n<span class=\"sd\">            run_id (str)</span>\n<span class=\"sd\">            event (DagsterEvent)</span>\n<span class=\"sd\">        &quot;&quot;&quot;</span>\n\n    <span class=\"nd\">@abstractmethod</span>\n    <span class=\"k\">def</span> <span class=\"nf\">get_runs</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">filters</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"n\">cursor</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"n\">limit</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">):</span>\n        <span class=\"sd\">&quot;&quot;&quot;Return all the runs present in the storage that match the given filters.</span>\n\n<span class=\"sd\">        Args:</span>\n<span class=\"sd\">            filters (Optional[PipelineRunsFilter]) -- The</span>\n<span class=\"sd\">                :py:class:`~dagster.core.storage.pipeline_run.PipelineRunsFilter` by which to filter</span>\n<span class=\"sd\">                runs</span>\n<span class=\"sd\">            cursor (Optional[str]): Starting cursor (run_id) of range of runs</span>\n<span class=\"sd\">            limit (Optional[int]): Number of results to get. Defaults to infinite.</span>\n\n<span class=\"sd\">        Returns:</span>\n<span class=\"sd\">            List[PipelineRun]</span>\n<span class=\"sd\">        &quot;&quot;&quot;</span>\n\n    <span class=\"nd\">@abstractmethod</span>\n    <span class=\"k\">def</span> <span class=\"nf\">get_runs_count</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">filters</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">):</span>\n        <span class=\"sd\">&quot;&quot;&quot;Return the number of runs present in the storage that match the given filters.</span>\n\n<span class=\"sd\">        Args:</span>\n<span class=\"sd\">            filters (Optional[PipelineRunsFilter]) -- The</span>\n<span class=\"sd\">                :py:class:`~dagster.core.storage.pipeline_run.PipelineRunFilter` by which to filter</span>\n<span class=\"sd\">                runs</span>\n<span class=\"sd\">            cursor (Optional[str]): Starting cursor (run_id) of range of runs</span>\n<span class=\"sd\">            limit (Optional[int]): Number of results to get. Defaults to infinite.</span>\n\n<span class=\"sd\">        Returns:</span>\n<span class=\"sd\">            int: The number of runs that match the given filters.</span>\n<span class=\"sd\">        &quot;&quot;&quot;</span>\n\n    <span class=\"nd\">@abstractmethod</span>\n    <span class=\"k\">def</span> <span class=\"nf\">get_run_group</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">run_id</span><span class=\"p\">):</span>\n        <span class=\"sd\">&quot;&quot;&quot;Get the run group to which a given run belongs.</span>\n\n<span class=\"sd\">        Args:</span>\n<span class=\"sd\">            run_id (str): If the corresponding run is the descendant of some root run (i.e., there</span>\n<span class=\"sd\">                is a root_run_id on the :py:class:`PipelineRun`), that root run and all of its</span>\n<span class=\"sd\">                descendants are returned; otherwise, the group will consist only of the given run</span>\n<span class=\"sd\">                (a run that does not descend from any root is its own root).</span>\n\n<span class=\"sd\">        Returns:</span>\n<span class=\"sd\">            Optional[Tuple[string, List[PipelineRun]]]: If there is a corresponding run group, tuple</span>\n<span class=\"sd\">                whose first element is the root_run_id and whose second element is a list of all the</span>\n<span class=\"sd\">                descendent runs. Otherwise `None`.</span>\n<span class=\"sd\">        &quot;&quot;&quot;</span>\n\n    <span class=\"nd\">@abstractmethod</span>\n    <span class=\"k\">def</span> <span class=\"nf\">get_run_groups</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">filters</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"n\">cursor</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"n\">limit</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">):</span>\n        <span class=\"sd\">&quot;&quot;&quot;Return all of the run groups present in the storage that include rows matching the</span>\n<span class=\"sd\">        given filter.</span>\n\n<span class=\"sd\">        Args:</span>\n<span class=\"sd\">            filter (Optional[PipelineRunsFilter]) -- The</span>\n<span class=\"sd\">                :py:class:`~dagster.core.storage.pipeline_run.PipelineRunsFilter` by which to filter</span>\n<span class=\"sd\">                runs</span>\n<span class=\"sd\">            cursor (Optional[str]): Starting cursor (run_id) of range of runs</span>\n<span class=\"sd\">            limit (Optional[int]): Number of results to get. Defaults to infinite.</span>\n\n<span class=\"sd\">        Returns:</span>\n<span class=\"sd\">            Dict[Dict[Union[PipelineRun, int]]]: Specifically, a dict of the form</span>\n<span class=\"sd\">                ``{&#39;pipeline_run_id&#39;: {&#39;runs&#39;: [PipelineRun, ...], &#39;count&#39;: int}, ...}``. The</span>\n<span class=\"sd\">                instances of :py:class:`~dagster.core.pipeline_run.PipelineRun` returned in this</span>\n<span class=\"sd\">                data structure correspond to all of the runs that would have been returned by</span>\n<span class=\"sd\">                calling :py:meth:`get_run_groups` with the same arguments, plus their corresponding</span>\n<span class=\"sd\">                root runs, if any. The keys of this structure are the run_ids of all of the root</span>\n<span class=\"sd\">                runs (a run with no root is its own root). The integer counts are inclusive of all</span>\n<span class=\"sd\">                of the root runs&#39; children, including those that would not have been returned by</span>\n<span class=\"sd\">                calling :py:meth:`get_run_groups` with the same arguments, but exclusive of the root</span>\n<span class=\"sd\">                run itself; i.e., if a run has no children, the count will be 0.</span>\n<span class=\"sd\">        &quot;&quot;&quot;</span>\n\n        <span class=\"c1\"># Note that we could have made the opposite decision here and filtered for root runs</span>\n        <span class=\"c1\"># matching a given filter, etc., rather than for child runs; so that asking for the last 5</span>\n        <span class=\"c1\"># run groups would give the last 5 roots and their descendants, rather than the last 5</span>\n        <span class=\"c1\"># children and their roots. Consider the case where we have just been retrying runs</span>\n        <span class=\"c1\"># belonging to a group created long ago; it makes sense to bump these to the top of the</span>\n        <span class=\"c1\"># interface rather than burying them deeply paginated down. Note also that this query can</span>\n        <span class=\"c1\"># return no more run groups than there are runs in an equivalent call to get_runs, and no</span>\n        <span class=\"c1\"># more than 2x total instances of PipelineRun.</span>\n\n    <span class=\"nd\">@abstractmethod</span>\n    <span class=\"k\">def</span> <span class=\"nf\">get_run_by_id</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">run_id</span><span class=\"p\">):</span>\n        <span class=\"sd\">&quot;&quot;&quot;Get a run by its id.</span>\n\n<span class=\"sd\">        Args:</span>\n<span class=\"sd\">            run_id (str): The id of the run</span>\n\n<span class=\"sd\">        Returns:</span>\n<span class=\"sd\">            Optional[PipelineRun]</span>\n<span class=\"sd\">        &quot;&quot;&quot;</span>\n\n    <span class=\"nd\">@abstractmethod</span>\n    <span class=\"k\">def</span> <span class=\"nf\">get_run_tags</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"sd\">&quot;&quot;&quot;Get a list of tag keys and the values that have been associated with them.</span>\n\n<span class=\"sd\">        Returns:</span>\n<span class=\"sd\">            List[Tuple[string, Set[string]]]</span>\n<span class=\"sd\">        &quot;&quot;&quot;</span>\n\n    <span class=\"nd\">@abstractmethod</span>\n    <span class=\"k\">def</span> <span class=\"nf\">add_run_tags</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">run_id</span><span class=\"p\">,</span> <span class=\"n\">new_tags</span><span class=\"p\">):</span>\n        <span class=\"sd\">&quot;&quot;&quot;Add additional tags for a pipeline run.</span>\n\n<span class=\"sd\">        Args:</span>\n<span class=\"sd\">            run_id (str)</span>\n<span class=\"sd\">            new_tags (Dict[string, string])</span>\n<span class=\"sd\">        &quot;&quot;&quot;</span>\n\n    <span class=\"nd\">@abstractmethod</span>\n    <span class=\"k\">def</span> <span class=\"nf\">has_run</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">run_id</span><span class=\"p\">):</span>\n        <span class=\"sd\">&quot;&quot;&quot;Check if the storage contains a run.</span>\n\n<span class=\"sd\">        Args:</span>\n<span class=\"sd\">            run_id (str): The id of the run</span>\n\n<span class=\"sd\">        Returns:</span>\n<span class=\"sd\">            bool</span>\n<span class=\"sd\">        &quot;&quot;&quot;</span>\n\n    <span class=\"nd\">@abstractmethod</span>\n    <span class=\"k\">def</span> <span class=\"nf\">has_pipeline_snapshot</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">pipeline_snapshot_id</span><span class=\"p\">):</span>\n        <span class=\"sd\">&quot;&quot;&quot;Check to see if storage contains a pipeline snapshot.</span>\n\n<span class=\"sd\">        Args:</span>\n<span class=\"sd\">            pipeline_snapshot_id (str): The id of the run.</span>\n\n<span class=\"sd\">        Returns:</span>\n<span class=\"sd\">            bool</span>\n<span class=\"sd\">        &quot;&quot;&quot;</span>\n\n    <span class=\"nd\">@abstractmethod</span>\n    <span class=\"k\">def</span> <span class=\"nf\">add_pipeline_snapshot</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">pipeline_snapshot</span><span class=\"p\">):</span>\n        <span class=\"sd\">&quot;&quot;&quot;Add a pipeline snapshot to the run store.</span>\n\n<span class=\"sd\">        Pipeline snapshots are content-addressable, meaning</span>\n<span class=\"sd\">        that the ID for a snapshot is a hash based on the</span>\n<span class=\"sd\">        body of the snapshot. This function returns</span>\n<span class=\"sd\">        that snapshot ID.</span>\n\n<span class=\"sd\">        Args:</span>\n<span class=\"sd\">            pipeline_snapshot (PipelineSnapshot)</span>\n\n<span class=\"sd\">        Return:</span>\n<span class=\"sd\">            str: The pipeline_snapshot_id</span>\n<span class=\"sd\">        &quot;&quot;&quot;</span>\n\n    <span class=\"nd\">@abstractmethod</span>\n    <span class=\"k\">def</span> <span class=\"nf\">get_pipeline_snapshot</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">pipeline_snapshot_id</span><span class=\"p\">):</span>\n        <span class=\"sd\">&quot;&quot;&quot;Fetch a snapshot by ID</span>\n\n<span class=\"sd\">        Args:</span>\n<span class=\"sd\">            pipeline_snapshot_id (str)</span>\n\n<span class=\"sd\">        Returns:</span>\n<span class=\"sd\">            PipelineSnapshot</span>\n<span class=\"sd\">        &quot;&quot;&quot;</span>\n\n    <span class=\"nd\">@abstractmethod</span>\n    <span class=\"k\">def</span> <span class=\"nf\">has_execution_plan_snapshot</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">execution_plan_snapshot_id</span><span class=\"p\">):</span>\n        <span class=\"sd\">&quot;&quot;&quot;Check to see if storage contains an execution plan snapshot.</span>\n\n<span class=\"sd\">        Args:</span>\n<span class=\"sd\">            execution_plan_snapshot_id (str): The id of the execution plan.</span>\n\n<span class=\"sd\">        Returns:</span>\n<span class=\"sd\">            bool</span>\n<span class=\"sd\">        &quot;&quot;&quot;</span>\n\n    <span class=\"nd\">@abstractmethod</span>\n    <span class=\"k\">def</span> <span class=\"nf\">add_execution_plan_snapshot</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">execution_plan_snapshot</span><span class=\"p\">):</span>\n        <span class=\"sd\">&quot;&quot;&quot;Add an execution plan snapshot to the run store.</span>\n\n<span class=\"sd\">        Execution plan snapshots are content-addressable, meaning</span>\n<span class=\"sd\">        that the ID for a snapshot is a hash based on the</span>\n<span class=\"sd\">        body of the snapshot. This function returns</span>\n<span class=\"sd\">        that snapshot ID.</span>\n\n<span class=\"sd\">        Args:</span>\n<span class=\"sd\">            execution_plan_snapshot (ExecutionPlanSnapshot)</span>\n\n<span class=\"sd\">        Return:</span>\n<span class=\"sd\">            str: The execution_plan_snapshot_id</span>\n<span class=\"sd\">        &quot;&quot;&quot;</span>\n\n    <span class=\"nd\">@abstractmethod</span>\n    <span class=\"k\">def</span> <span class=\"nf\">get_execution_plan_snapshot</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">execution_plan_snapshot_id</span><span class=\"p\">):</span>\n        <span class=\"sd\">&quot;&quot;&quot;Fetch a snapshot by ID</span>\n\n<span class=\"sd\">        Args:</span>\n<span class=\"sd\">            execution_plan_snapshot_id (str)</span>\n\n<span class=\"sd\">        Returns:</span>\n<span class=\"sd\">            ExecutionPlanSnapshot</span>\n<span class=\"sd\">        &quot;&quot;&quot;</span>\n\n    <span class=\"nd\">@abstractmethod</span>\n    <span class=\"k\">def</span> <span class=\"nf\">wipe</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"sd\">&quot;&quot;&quot;Clears the run storage.&quot;&quot;&quot;</span>\n\n    <span class=\"nd\">@abstractmethod</span>\n    <span class=\"k\">def</span> <span class=\"nf\">delete_run</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">run_id</span><span class=\"p\">):</span>\n        <span class=\"sd\">&quot;&quot;&quot;Remove a run from storage&quot;&quot;&quot;</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">dispose</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"sd\">&quot;&quot;&quot;Explicit lifecycle management.&quot;&quot;&quot;</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">optimize_for_dagit</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">statement_timeout</span><span class=\"p\">):</span>\n        <span class=\"sd\">&quot;&quot;&quot;Allows for optimizing database connection / use in the context of a long lived dagit process&quot;&quot;&quot;</span></div>\n</pre></div>", "current_page_name": "_modules/dagster/core/storage/runs/base", "sidebars": ["globaltoc.html", "searchbox.html"], "customsidebar": null, "alabaster_version": "0.7.12"}